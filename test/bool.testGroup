#!/usr/bin/env rexx

parse source . . s

group = .TestGroup~new(s)
group~add(.bool.testGroup)

if group~isAutomatedTest then return group

testResult = group~suite~execute~~print

return testResult

::requires 'ooTest.frm'
::requires 'orxpython.cls'

/*
    https://docs.python.org/3/library/stdtypes.html#boolean-type-bool

    "The bool type has exactly two constant instances: True and False."

    https://docs.python.org/3/library/stdtypes.html#truth-value-testing

    "Here are most of the built-in objects considered false:
    - constants defined to be false: None and False
    - zero of any numeric type: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)
    - empty sequences and collections: '', (), [], {}, set(), range(0)"
*/
::class bool.testGroup public subclass ooTestCase
    ::method setUp
        expose py
        py = .Python~new

    ::method test_hasExactlyOneConstantTrueInstance
        expose py
        bool1 = py~True
        bool2 = py~bool(py~int(1))

        identity1 = py~id(bool1)
        identity2 = py~id(bool2)

        self~assertEquals(unbox(identity1), unbox(identity2))
        self~assertSame(unbox(identity1), unbox(identity2))

    ::method test_hasExactlyOneConstantFalseInstance
        expose py
        bool1 = py~False
        bool2 = py~bool(py~int(0))

        identity1 = py~id(bool1)
        identity2 = py~id(bool2)

        self~assertEquals(unbox(identity1), unbox(identity2))
        self~assertSame(unbox(identity1), unbox(identity2))

    ::method test_rexxPythonTrueCompatibility
        expose py
        self~assertTrue(unbox(py~True))

        self~assertTrue(.true = unbox(py~True))
        self~assertTrue(.true == unbox(py~True))

        self~assertFalse(.false = unbox(py~True))
        self~assertFalse(.false == unbox(py~True))

        self~assertTrue(unbox(py~True) = .true)

    ::method test_rexxPythonFalseCompatibility
        expose py
        self~assertFalse(unbox(py~False))

        self~assertFalse(.true = unbox(py~False))
        self~assertFalse(.true == unbox(py~False))

        self~assertTrue(.false = unbox(py~False))
        self~assertTrue(.false == unbox(py~False))

    ::method test_objectsConsideredTrue
        expose py
        self~assertTrue(unbox(py~bool(py~True)))
        self~assertTrue(unbox(py~bool(py~int(1))))
        self~assertTrue(unbox(py~bool(py~float(1.0))))
        self~assertTrue(unbox(py~bool(py~complex('1j'))))
        -- todo: Decimal(0)
        -- todo: Fraction(0, 1)
        self~assertTrue(unbox(py~bool('a')))
        self~assertTrue(unbox(py~bool(py~tuple(py~range(py~int(1))))))
        self~assertTrue(unbox(py~bool(py~list~~append('a'))))
        dict = py~dict
        dict['key'] = 'value'
        self~assertTrue(unbox(py~bool(dict)))
        self~assertTrue(unbox(py~bool(py~set~~add('a'))))
        self~assertTrue(unbox(py~bool(py~range(py~int(1)))))

    ::method test_objectsConsideredFalse
        expose py
        -- todo: None
        self~assertFalse(unbox(py~bool(py~False)))
        self~assertFalse(unbox(py~bool(py~int(0))))
        self~assertFalse(unbox(py~bool(py~float(0.0))))
        self~assertFalse(unbox(py~bool(py~complex('0j'))))
        -- todo: Decimal(0)
        -- todo: Fraction(0, 1)
        self~assertFalse(unbox(py~bool('')))
        self~assertFalse(unbox(py~bool(py~tuple)))
        self~assertFalse(unbox(py~bool(py~list)))
        self~assertFalse(unbox(py~bool(py~dict)))
        self~assertFalse(unbox(py~bool(py~set)))
        self~assertFalse(unbox(py~bool(py~range(py~int(0)))))
