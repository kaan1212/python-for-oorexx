#!/usr/bin/env rexx

parse source . . s

group = .TestGroup~new(s)
group~add(.bool.testGroup)

if group~isAutomatedTest then return group

testResult = group~suite~execute~~print

return testResult

::requires 'ooTest.frm'
::requires 'orxpython.cls'

/*
    https://docs.python.org/3/library/stdtypes.html#boolean-type-bool

    "The bool type has exactly two constant instances: True and False."

    https://docs.python.org/3/library/stdtypes.html#truth-value-testing

    "Here are most of the built-in objects considered false:
    - constants defined to be false: None and False
    - zero of any numeric type: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)
    - empty sequences and collections: '', (), [], {}, set(), range(0)"
*/
::class bool.testGroup public subclass ooTestCase
    ::method test_hasExactlyOneConstantTrueInstance
        bool1 = .Python~True
        bool2 = .Python~bool(.Python~int(1))

        identity1 = .Python~id(bool1)
        identity2 = .Python~id(bool2)

        self~assertEquals(unbox(identity1), unbox(identity2))
        self~assertSame(unbox(identity1), unbox(identity2))

    ::method test_hasExactlyOneConstantFalseInstance
        bool1 = .Python~False
        bool2 = .Python~bool(.Python~int(0))

        identity1 = .Python~id(bool1)
        identity2 = .Python~id(bool2)

        self~assertEquals(unbox(identity1), unbox(identity2))
        self~assertSame(unbox(identity1), unbox(identity2))

    ::method test_rexxPythonTrueCompatibility
        self~assertTrue(unbox(.Python~True))

        self~assertTrue(.true = unbox(.Python~True))
        self~assertTrue(.true == unbox(.Python~True))

        self~assertFalse(.false = unbox(.Python~True))
        self~assertFalse(.false == unbox(.Python~True))

        self~assertTrue(unbox(.Python~True) = .true)

    ::method test_rexxPythonFalseCompatibility
        self~assertFalse(unbox(.Python~False))

        self~assertFalse(.true = unbox(.Python~False))
        self~assertFalse(.true == unbox(.Python~False))

        self~assertTrue(.false = unbox(.Python~False))
        self~assertTrue(.false == unbox(.Python~False))

    ::method test_objectsConsideredTrue
        self~assertTrue(unbox(.Python~bool(.Python~True)))
        self~assertTrue(unbox(.Python~bool(.Python~int(1))))
        self~assertTrue(unbox(.Python~bool(.Python~float(1.0))))
        self~assertTrue(unbox(.Python~bool(.Python~complex('1j'))))
        -- todo: Decimal(0)
        -- todo: Fraction(0, 1)
        self~assertTrue(unbox(.Python~bool('a')))
        self~assertTrue(unbox(.Python~bool(.Python~tuple(.Python~range(.Python~int(1))))))
        self~assertTrue(unbox(.Python~bool(.Python~list~~append('a'))))
        dict = .Python~dict
        dict['key'] = 'value'
        self~assertTrue(unbox(.Python~bool(dict)))
        self~assertTrue(unbox(.Python~bool(.Python~set~~add('a'))))
        self~assertTrue(unbox(.Python~bool(.Python~range(.Python~int(1)))))

    ::method test_objectsConsideredFalse
        -- todo: None
        self~assertFalse(unbox(.Python~bool(.Python~False)))
        self~assertFalse(unbox(.Python~bool(.Python~int(0))))
        self~assertFalse(unbox(.Python~bool(.Python~float(0.0))))
        self~assertFalse(unbox(.Python~bool(.Python~complex('0j'))))
        -- todo: Decimal(0)
        -- todo: Fraction(0, 1)
        self~assertFalse(unbox(.Python~bool('')))
        self~assertFalse(unbox(.Python~bool(.Python~tuple)))
        self~assertFalse(unbox(.Python~bool(.Python~list)))
        self~assertFalse(unbox(.Python~bool(.Python~dict)))
        self~assertFalse(unbox(.Python~bool(.Python~set)))
        self~assertFalse(unbox(.Python~bool(.Python~range(.Python~int(0)))))
