#!/usr/bin/env rexx

parse source . . s

group = .TestGroup~new(s)
group~add(.builtins.testGroup)

if group~isAutomatedTest then return group

testResult = group~suite~execute~~print

return testResult

::requires 'ooTest.frm'
::requires 'orxpython.cls'

/*
    See: https://docs.python.org/3/library/functions.html

    Coverage: 48 of 71 built-in functions
*/
::class builtins.testGroup public subclass ooTestCase
    -- Return the absolute value of a number.
    ::method test_abs
        x = .Python~int(-1)
        actual = .Python~abs(x)
        self~assertSame(1, unbox(actual))

    -- Return True if all elements of the iterable are true (or if the iterable is empty).
    ::method test_all
        iterable = .Python[.Python~True, .Python~True, .Python~True]
        actual = .Python~all(iterable)
        self~assertTrue(unbox(actual))

    -- Return True if any element of the iterable is true.
    ::method test_any
        iterable = .Python[.Python~True, .Python~False .Python~False]
        actual = .Python~any(iterable)
        self~assertTrue(unbox(actual))

    -- Return a string containing a printable representation of an object, but escape the non-ASCII characters.
    ::method test_ascii
        actual = .Python~ascii('Euro sign: €')
        self~assertSame("'Euro sign: \u20ac'", unbox(actual))

    -- Convert an integer number to a binary string prefixed with “0b”.
    ::method test_bin
        x = .Python~int(3)
        actual = .Python~bin(x)
        self~assertSame('0b11', unbox(actual))

    -- Return a Boolean value, i.e. one of True or False.
    ::method test_bool
        object = .Python~int(0)
        actual = .Python~bool(object)
        self~assertFalse(unbox(actual))

    -- This function drops you into the debugger at the call site.
    ::method test_breakpoint
        -- Smoke test
        self~assertTrue(.true)

    -- Return a new array of bytes.
    ::method test_bytearray
        -- Smoke test
        actual = .Python~bytearray
        self~assertSame(0, unbox(.Python~len(actual)))

    -- Return a new “bytes” object which is an immutable sequence of integers in the range 0 <= x < 256.
    ::method test_bytes
        -- Smoke test
        actual = .Python~bytes
        self~assertSame(0, unbox(.Python~len(actual)))

    -- Return the string representing a character whose Unicode code point is the integer i.
    ::method test_chr
        i = .Python~int(97)
        actual = .Python~chr(i)
        self~assertSame('a', unbox(actual))

    -- Compile the source into a code or AST object.
    ::method test_compile
        code = .Python~compile('1+2', '<string>', 'eval')
        actual = .Python~eval(code)
        self~assertSame(3, unbox(actual))

    -- Convert a single string or number to a complex number, or create a complex number from real and imaginary parts.
    ::method test_complex
        actual = .Python~complex('+1.23')
        self~assertSame('(1.23+0j)', actual~py.fromPythonString)

    -- Create a new dictionary.
    ::method test_dict
        dict = .Python~dict
        dict['one'] = .Python~int(1)
        dict['two'] = .Python~int(2)
        dict['three'] = .Python~int(3)

        actual = dict['two']

        self~assertSame(2, unbox(actual))

    -- Take two (non-complex) numbers as arguments and return a pair of numbers consisting of their quotient and remainder when using integer division.
    ::method test_divmod
        a = .Python~int(5)
        b = .Python~int(2)

        actual = .Python~divmod(a, b)

        self~assertSame('(2, 1)', actual~py.fromPythonString)

    -- Return an enumerate object. iterable must be a sequence, an iterator, or some other object which supports iteration.
    ::method test_enumerate
        seasons = .Python['Spring', 'Summer', 'Fall', 'Winter']
        actual = .Python~list(.Python~enumerate(seasons))
        self~assertSame("[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]", actual~py.fromPythonString)

    -- The expression argument is parsed and evaluated as a Python expression.
    ::method test_eval
        actual = .Python~eval('1+1')
        self~assertSame(2, unbox(actual))

    -- Return a floating-point number constructed from a number or a string.
    ::method test_float
        actual = .Python~float(1.23)
        self~assertSame(1.23, unbox(actual))

    -- Convert a value to a “formatted” representation, as controlled by format_spec.
    ::method test_format
        value = .Python~int(255)
        actual = .Python~format(value, '#x')
        self~assertSame('0xff', unbox(actual))

    -- Return a new frozenset object.
    ::method test_frozenset
        set = .Python~set
        set~add('a')
        set~add('b')
        set~add('c')

        frozen = .Python~frozenset(set)
        actual = .Python~len(frozen)

        self~assertSame(3, unbox(actual))

    -- Return the value of the named attribute of object.
    ::method test_getattr
        actual = .Python~getattr(.Python~str, 'swapcase')
        self~assertTrue(actual~py.fromPythonString~startsWith('<built-in method swapcase of str object at 0x'))

    -- The result is True if the string is the name of one of the object’s attributes, False if not.
    ::method test_hasattr
        object = .Python~frozenset
        actual = .Python~hasattr(object, 'add')
        self~assertFalse(unbox(actual))

    -- Return the hash value of the object (if it has one).
    ::method test_hash
        actual = .Python~hash('Rexx')
        self~assertSame('NUM', datatype(unbox(actual)))

    -- Invoke the built-in help system. (This function is intended for interactive use.)
    ::method test_help
        -- Smoke test
        self~assertTrue(.true)

    -- Convert an integer number to a lowercase hexadecimal string prefixed with “0x”.
    ::method test_hex
        x = .Python~int(255)
        actual = .Python~hex(x)
        self~assertSame('0xff', unbox(actual))

    -- Return the “identity” of an object.
    -- his is an integer which is guaranteed to be unique and constant for this object during its lifetime.
    ::method test_id
        actual = .Python~id('Rexx')
        self~assertSame('NUM', datatype(unbox(actual)))

    -- Return an integer object constructed from a number or a string, or return 0 if no arguments are given.
    ::method test_int
        actual = .Python~int(123)
        self~assertSame(123, unbox(actual))

    -- Return an iterator object.
    ::method test_iter
        stop = .Python~int(10)
        object = .Python~range(stop)
        iterator = .Python~iter(object)

        .Python~next(iterator)
        .Python~next(iterator)
        .Python~next(iterator)
        actual = .Python~next(iterator)

        self~assertSame(3, unbox(actual))

    -- Return the length (the number of items) of an object.
    ::method test_len
        actual = .Python~len('Rexx')
        self~assertSame(4, unbox(actual))

    -- Create a new list.
    ::method test_list
        list = .Python~list
        list~append('C')
        list~append('Python')
        list~append('Rexx')

        index = .Python~int(1)
        actual = list[index]

        self~assertSame('Python', unbox(actual))

    -- Return the largest item in an iterable or the largest of two or more arguments.
    ::method test_max
        actual = .Python~max('cdab')
        self~assertSame('d', unbox(actual))

    -- Return the smallest item in an iterable or the smallest of two or more arguments.
    ::method test_min
        actual = .Python~min('cdab')
        self~assertSame('a', unbox(actual))

    -- Retrieve the next item from the iterator.
    ::method test_next
        stop = .Python~int(10)
        object = .Python~range(stop)
        iterator = .Python~iter(object)

        .Python~next(iterator)
        .Python~next(iterator)
        .Python~next(iterator)
        actual = .Python~next(iterator)

        self~assertSame(3, unbox(actual))

    -- This is the ultimate base class of all other classes.
    ::method test_object
        actual = .Python~object
        self~assertTrue(actual~py.fromPythonString~startsWith('<object object at 0x'))

    -- Convert an integer number to an octal string prefixed with “0o”.
    ::method test_oct
        x = .Python~int(8)
        actual = .Python~oct(x)
        self~assertSame('0o10', unbox(actual))

    -- Open file and return a corresponding file object.
    ::method test_open
        -- Write to file.
        f = .Python~open('test-output/test_open.txt', 'w')
        f~write('hello, world')
        f~close

        -- Read from file.
        f = .Python~open('test-output/test_open.txt')
        actual = f~read
        f~close
        self~assertSame('hello, world', unbox(actual))

    -- Given a string representing one Unicode character, return an integer representing the Unicode code point of that character.
    ::method test_ord
        actual = .Python~ord('a')
        self~assertSame(97, unbox(actual))

    -- Return base to the power exp.
    ::method test_pow
        base = .Python~int(2)
        exp = .Python~int(3)
        actual = .Python~pow(base, exp)
        self~assertSame(8, unbox(actual))

    -- Print objects.
    ::method test_print
        /*
            Python function parameters:

            print(*objects, sep=' ', end='\n', file=None, flush=False)
        */

        -- Print to file instead of stdout.
        f = .Python~open('test-output/test_print.txt', 'w')
        kwargs = .Python~kwargs
        kwargs['end'] = ''
        kwargs['file'] = f

        .Python~print('hello, world', kwargs)

        f~close

        -- Read from file.
        f = .Python~open('test-output/test_print.txt')
        actual = f~read
        f~close
        self~assertSame('hello, world', unbox(actual))

    -- Create a new range object.
    ::method test_range
        stop = .Python~int(10)
        actual = .Python~range(stop)
        self~assertSame('[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]', .Python~list(actual)~py.fromPythonString)

    -- Return a string containing a printable representation of an object.
    ::method test_repr
        actual = .Python~repr('Hello, Python!')
        self~assertSame("'Hello, Python!'", unbox(actual))

    -- Return a reverse iterator.
    ::method test_reversed
        seq = .Python['a', 'b', 'c']

        iterator = .Python~reversed(seq)
        actual = .Python~list(iterator)

        self~assertSame("['c', 'b', 'a']", actual~py.fromPythonString)

    -- Return number rounded to ndigits precision after the decimal point.
    ::method test_round
        -- See: https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues
        number = .Python~float(0.5)
        actual = .Python~round(number)
        self~assertSame(0, unbox(actual))

    -- Return a new set object.
    ::method test_set
        set = .Python~set
        set~add('a')
        set~add('b')
        set~add('b')
        set~add('c')
        set~add('c')
        set~add('c')

        actual = .Python~len(set)

        self~assertSame(3, unbox(actual))

    -- Return a slice object.
    ::method test_slice
        string = .Python~str('Hello, Python!')
        start = .Python~int(7)
        stop = .Python~int(13)
        slice = .Python~slice(start, stop)

        actual = string[slice]

        self~assertSame('Python', unbox(actual))

    -- Return a new sorted list from the items in iterable.
    ::method test_sorted
        actual = .Python~sorted('cdab')
        self~assertSame("['a', 'b', 'c', 'd']", actual~py.fromPythonString)

    -- Return a str version of object.
    ::method test_str
        actual = .Python~str('Hello, Python!')
        self~assertSame('Hello, Python!', unbox(actual))

    -- Create a new tuple.
    ::method test_tuple
        stop = .Python~int(3)
        iterable = .Python~range(stop)

        actual = .Python~tuple(iterable)

        self~assertSame('(0, 1, 2)', actual~py.fromPythonString)

    -- Iterate over several iterables in parallel, producing tuples with an item from each one.
    ::method test_zip
        iterable1 = .Python[.Python~int(1), .Python~int(2), .Python~int(3)]
        iterable2 = .Python['sugar', 'spice', 'everything nice']

        iterator = .Python~zip(iterable1, iterable2)
        actual = .Python~list(iterator)

        self~assertSame("[(1, 'sugar'), (2, 'spice'), (3, 'everything nice')]", actual~py.fromPythonString)
